entity_name: bridge_customer_source_of_income
domain: customer
table_type: bridge
layer: gold
grain_description: One row per source of income membership for each customer profile version.  Multi-valued relationship between profile versions and income sources. 

primary_keys:
  - customer_profile_version_sk
  - source_of_income_code

foreign_keys:
  - column: customer_profile_version_sk
    references: dim_customer_profile.customer_profile_version_sk
    description: Link to specific profile version

attributes:
  - name: customer_profile_version_sk
    datatype: BIGINT
    business_definition: Surrogate key of the profile version this income source belongs to
    nullable: false
    primary_key: true

  - name: customer_id
    datatype: BIGINT
    business_definition: Denormalized stable customer identifier (for convenience queries)
    nullable: false

  - name: source_of_income_code
    datatype: VARCHAR(100)
    business_definition: Income source enumeration code
    nullable: false
    primary_key: true
    enumeration_ref: enumerations/customer_source_of_income.yamlvalid_values: [SALARY, DIVIDEND, RENTAL, BUSINESS, PENSION, INVESTMENT, INHERITANCE, GIFT, OTHER, UNKNOWN]

  - name: load_ts
    datatype: TIMESTAMP
    business_definition: ETL ingestion timestamp
    nullable: false

set_membership_behavior: |
  Full set is re-materialized for each new profile version only when membership changes. 
  Bridge rows are immutable once created (tied to specific profile version).
  
hash_dependency:
  parent_set_hash_column: source_of_income_set_hash
  computation_logic: |
    1. Retrieve all source_of_income_code values for given customer_profile_version_sk
    2. Normalize each code: UPPER(TRIM)
    3. Deduplicate (should not happen in well-formed data)
    4. Sort codes ascending alphabetically
    5. Join with "|" delimiter (empty set -> "")
    6. SHA256(joined_string) -> source_of_income_set_hash
    7. Store hash in dim_customer_profile for this version
  
  example_sql: |
    SELECT SHA256(STRING_AGG(source_of_income_code, '|' ORDER BY source_of_income_code))
    FROM bridge_customer_source_of_income
    WHERE customer_profile_version_sk = :version_sk;

data_quality_rules:
  - rule: no_duplicates
    description: No duplicate (customer_profile_version_sk, source_of_income_code) combinations
    
  - rule: valid_enumeration
    description: All source_of_income_code values must exist in enumeration file
    
  - rule: fk_integrity
    description: customer_profile_version_sk must exist in dim_customer_profile
    
  - rule: at_least_one_member
    description: Each customer_profile_version_sk should have at least 1 source (recommended, not enforced)

indexes:
  - name: pk_bridge_income_source
    type: primary_key
    columns: [customer_profile_version_sk, source_of_income_code]
    
  - name: idx_customer_id
    type: non_unique
    columns: [customer_id]
    description: Fast lookup by customer

adr_refs:
  - ADR-002-multi-valued-sets-via-bridge.md
  - ADR-003-enumeration-with-other-pattern. md

sample_rows:
  - customer_profile_version_sk: 102938
    customer_id: 556677
    source_of_income_code: "SALARY"
    load_ts: "2025-12-01T08:05:10Z"
    
  - customer_profile_version_sk: 102938
    customer_id: 556677
    source_of_income_code: "DIVIDEND"
    load_ts: "2025-12-01T08:05:10Z"

version: 2. 0
last_updated: 2025-12-01
owner: Data Architecture Team